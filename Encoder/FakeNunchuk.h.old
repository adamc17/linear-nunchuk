
#ifndef FAKENUNCHUK
#define FAKENUNCHUK

#include <Wire.h>
#include <stdint.h>


class FakeNunchuk {
	public:
		enum {
			NunchukAddr = 0x52,
			EncryptionEnabled = 0xAA,
			EncryptionDisabled = 0x55
		};

		enum ExpansionRegisterAddress {
			OutputData = 0x00,
			IDRegister = 0xFA,
			CalibrationRegister = 0x20,
			EncryptionRegister = 0xF0
		};

		enum NunchukState {
			NUNCHUK_WAITING_FOR_HANDSHAKE,
			NUNCHUK_HANDSHAKING,
			NUNCHUK_READ_REQUESTED,
			NUNCHUK_READ_COMPLETED
		};
		struct DataReport {
			uint8_t JoystickAxes[2];
			uint8_t AccelAxesHigh[3];
			unsigned int AccelZLow : 2;
			unsigned int AccelYLow : 2;
			unsigned int AccelXLow : 2;
			bool ButtonC : 1;
			bool ButtonZ : 1;
			/*
			typedef uint16_t uint10_t; // Accel data is actually 10-bit int (0-1024) - we will drop the highest bits!
			void setAccelAxes(uint10_t X, uint10_t Y, uint10_t Z) {
			  union {
			    uint16_t fullrange;
			    struct {
			      unsigned : 6; // padding
			      uint8_t highBits : 8;
			      unsigned int lowBits : 2;
			    };
			  };
			}
			*/
		};

		FakeNunchuk() : state(NUNCHUK_WAITING_FOR_HANDSHAKE), addr(IDRegister),  receivedBytes(0), gotRequestEvent(0), encrypted(false), sentID(false) {
		}

		void begin() {
			self = this;
			Wire.begin(NunchukAddr);
#define TWI_FREQ_NUNCHUCK 400000L
			TWBR = ((CPU_FREQ / TWI_FREQ_NUNCHUCK) - 16) / 2;
			Wire.onReceive(&FakeNunchuk::_receiveTrampoline);
			Wire.onRequest(&FakeNunchuk::_requestTrampoline);
		}
		void beginEncrypted() {
			encrypted = true;
			begin();
		}

		void printReceiveData() {
			bool didPrint = false;

			if (gotRequestEvent > 0) {
				Serial.print("Got ");
				Serial.print(gotRequestEvent, DEC);
				Serial.print(" request event(s). ");
				gotRequestEvent = 0;
				didPrint = true;
			}
			if (receivedBytes > 0) {
				Serial.print("Received data: ");
				for (uint8_t i = 0; i < receivedBytes; ++i) {
					Serial.print(bytes[i], HEX);
				}
				receivedBytes = 0;
				didPrint = true;
			}
			if (didPrint) {
				Serial.println("");
			}
		}

		DataReport report;
	private:

		static const uint8_t bufSize = 32;
		NunchukState state;
		uint8_t addr;
		uint8_t bytes[bufSize];
		uint8_t receivedBytes;
		uint16_t gotRequestEvent;
		void receiveEvent(int howMany) {
			addr = Wire.read();
			uint8_t count = 0;
			while (Wire.available() && count < bufSize) {
				char c = Wire.read();
				memcpy(&(bytes[count]), &c, 1);
				count++;
			}
			switch (addr) {
				case OutputData:
				case IDRegister:
				case CalibrationRegister:
					// these just will tell us what to send on the next request
					if (count > 0) {
						Serial.println("Wrote data when not expected!");
					}
					break;
				case EncryptionRegister:
					if (count > 0) {
						switch (bytes[0]) {
							case EncryptionEnabled:
								Serial.println("encryption!");
								encrypted = true;
								break;
							case EncryptionDisabled:
								encrypted = false;
								break;
							default:
								Serial.println("unexpected encryption value");
						}

						switch (count) {
							case 2: {
									switch (bytes[0]) {
										case 0xf0:
											if (bytes[1] == 0x55) {
												// disable encryption
												encrypted = false;
											} else if (bytes[1] == AA) {

											}
											if (bytes[0] == 0xf0 && bytes[1] == 0x55) {
												// disable encryption

											};
											/*
											Serial.print("Expected bytes: ");
											Serial.print(howMany, DEC);
											Serial.print(" Got bytes: ");
											Serial.print(count, DEC);
											Serial.print(" Bytes: ");
											for (uint8_t i = 0; i < count; ++i) {
											  Serial.print(bytes[i], HEX);
											}
											Serial.println("");

											*/
									}

									void requestEvent() {
										uint8_t outbuf[sizeof(DataReport)];
										if (!sentID) {
											static const uint8_t NunchuckID[6] = {0x00, 0x00, 0xA4, 0x20, 0x00, 0x00};
											memcpy(&(outbuf[0]), &(NunchuckID[0]), 6);
											sentID = true;
										} else {
											memcpy(&(outbuf[0]), &report, sizeof(DataReport));
										}
										if (encrypted) {
											for (uint8_t i = 0; i < sizeof(DataReport); ++i) {
												encryptByte(outbuf[i]);
											}
										}
										Wire.write(outbuf, sizeof(outbuf));
										gotRequestEvent++;
									}
									void encryptByte(uint8_t & val) {
										val = (val - 0x17) ^ 0x17;
									}

									void decryptByte(uint8_t & val) {
										val = (val ^ 0x17) + 0x17;
									}
									bool encrypted;
									bool sentID;
									static FakeNunchuk * self;
									static void _receiveTrampoline(int howMany) {
										self->receiveEvent(howMany);
									}
									static void _requestTrampoline() {
										self->requestEvent();
									}


								};

								FakeNunchuk * FakeNunchuk::self = NULL;

#endif
